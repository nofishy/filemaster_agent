import { StateGraph, CompiledStateGraph, AnnotationRoot, MessagesAnnotation } from "@langchain/langgraph";
/**
 * State schema for the multi-agent swarm.
 */
declare const SwarmState: AnnotationRoot<{
    activeAgent: {
        (): import("@langchain/langgraph").LastValue<string>;
        (annotation: import("@langchain/langgraph").SingleReducer<string, string>): import("@langchain/langgraph").BinaryOperatorAggregate<string, string>;
        Root: <S extends import("@langchain/langgraph").StateDefinition>(sd: S) => AnnotationRoot<S>;
    };
    messages: import("@langchain/langgraph").BinaryOperatorAggregate<import("@langchain/core/messages").BaseMessage[], import("@langchain/langgraph").Messages>;
}>;
/**
 * Add a router to the currently active agent to the StateGraph.
 *
 * @param builder The graph builder (StateGraph) to add the router to.
 * @param routeTo A list of agent (node) names to route to.
 * @param defaultActiveAgent Name of the agent to route to by default (if no agents are currently active).
 * @returns StateGraph with the router added.
 */
declare const addActiveAgentRouter: <AnnotationRootT extends AnnotationRoot<any> = AnnotationRoot<{
    activeAgent: {
        (): import("@langchain/langgraph").LastValue<string>;
        (annotation: import("@langchain/langgraph").SingleReducer<string, string>): import("@langchain/langgraph").BinaryOperatorAggregate<string, string>;
        Root: <S extends import("@langchain/langgraph").StateDefinition>(sd: S) => AnnotationRoot<S>;
    };
    messages: import("@langchain/langgraph").BinaryOperatorAggregate<import("@langchain/core/messages").BaseMessage[], import("@langchain/langgraph").Messages>;
}>>(builder: StateGraph<AnnotationRootT["spec"], AnnotationRootT["State"], AnnotationRootT["Update"], any, AnnotationRootT["spec"], AnnotationRootT["spec"], import("@langchain/langgraph").StateDefinition>, { routeTo, defaultActiveAgent, }: {
    routeTo: string[];
    defaultActiveAgent: string;
}) => StateGraph<AnnotationRootT["spec"], AnnotationRootT["State"], AnnotationRootT["Update"], any, AnnotationRootT["spec"], AnnotationRootT["spec"], import("@langchain/langgraph").StateDefinition>;
export type CreateSwarmParams<AnnotationRootT extends AnnotationRoot<any> = typeof SwarmState, AgentAnnotationRootT extends AnnotationRoot<any> = typeof MessagesAnnotation> = {
    agents: CompiledStateGraph<AgentAnnotationRootT["State"], AgentAnnotationRootT["Update"], string, AgentAnnotationRootT["spec"], AgentAnnotationRootT["spec"]>[];
    defaultActiveAgent: string;
    stateSchema?: AnnotationRootT;
};
/**
 * Create a multi-agent swarm.
 *
 * @param agents List of agents to add to the swarm
 * @param defaultActiveAgent Name of the agent to route to by default (if no agents are currently active).
 * @param stateSchema State schema to use for the multi-agent graph.
 * @returns A multi-agent swarm StateGraph.
 */
declare const createSwarm: <AnnotationRootT extends AnnotationRoot<any> = AnnotationRoot<{
    activeAgent: {
        (): import("@langchain/langgraph").LastValue<string>;
        (annotation: import("@langchain/langgraph").SingleReducer<string, string>): import("@langchain/langgraph").BinaryOperatorAggregate<string, string>;
        Root: <S extends import("@langchain/langgraph").StateDefinition>(sd: S) => AnnotationRoot<S>;
    };
    messages: import("@langchain/langgraph").BinaryOperatorAggregate<import("@langchain/core/messages").BaseMessage[], import("@langchain/langgraph").Messages>;
}>>({ agents, defaultActiveAgent, stateSchema, }: CreateSwarmParams<AnnotationRootT, AnnotationRoot<{
    messages: import("@langchain/langgraph").BinaryOperatorAggregate<import("@langchain/core/messages").BaseMessage[], import("@langchain/langgraph").Messages>;
}>>) => StateGraph<AnnotationRootT["spec"], AnnotationRootT["State"], AnnotationRootT["Update"], string, AnnotationRootT["spec"], AnnotationRootT["spec"], import("@langchain/langgraph").StateDefinition>;
export { createSwarm, addActiveAgentRouter, SwarmState };
